{"name":"Rotonde","tagline":"Module to Module framework","body":"# Motivations\r\n\r\nThis project aims to provide a better environment for building hardware projects with complexe interactions between the low level (micro-controllers/embedded software/...) and the higher level (eg. UI/UX for public access).\r\nIt also aims to resolves many of the common difficulties and caveats of modern embedded development.\r\n\r\nFrom previous observations, here is an unexhaustive list of the key concepts that should be obtained by using the rotonde project.\r\n\r\n- **Language-agnostic**. In a typical case, where the core of the architecture is usually a raspberryPi-like computer, there is no \"way-to-go\" like on iOS or android (which both have a forced unique language), this freedom of choice implies that useful pieces of codes or language bindings that you gather on the WEB can be of any language. The framework should not be tighted to a specific language, and if multiple languages are used, the usability of the framework should still feel native in all languages.\r\n- **Connected**. Building electronics in 2015 usually implies a connection to the WEB, which means that the framework give you the ability to seemlessly and securely add cloud code execution in the loop.\r\n- **Modular**. This framework has its origins in agencies, fastness of execution is a key feature of the framework. The framework should encourage a modular architecture, which allows highly efficient reuse of code from one project to another.\r\n- **Hardware abstraction**. One of the issue that you face when developping on embedded linux environment is the lack of unicity in the low level hardware access. For example, GPIO are not accessed the same way on a raspberryPI and an edison. The framework should greatly simplify the transfer of code from one architecture to another, without having to refactor existing code.\r\n- **UI friendly**. The whole system should be easily connected to a screen or any HID device, even a smartphone through wireless means, or both. any combination of WEB/touch screen/external device should be greatly simplified and interchangeable.\r\n- **Remotely debuggable**. Building custom devices implies remote support and debugging. The framework should provide an environment that is easily debuggable, even from a remote access. All modules should be individually observable, and interaction from a remote point is the key to cheap and responsive support.\r\n- **Cluster creation**. Inter connectivity of devices is a known complexe situation. This should be easily challenged by providing a clean way of creating meshes of devices. TODO check MQTT for amazon for IoT plateform\r\n\r\n# Setup \r\n\r\n## Requirements \r\n\r\n- some unix os (tested with success on Linux and OSX so far)\r\n- [Golang](https://golang.org/) (1.5.1, please tell us if you got it\r\n  working on previous versions, we didn't test them yet)\r\n- [Godep](http://godoc.org/github.com/tools/godep)\r\n\r\n## Compilation\r\n\r\nAssuming Golang had been installed, if it's not already done a workspace\r\ncan be set with  \r\n\r\n```bash\r\nexport GOPATH=$HOME/go\r\nmkdir $GOPATH\r\ngo get github.com/HackerLoop/rotonde && go get github.com/tools/godep\r\ncd $GOPATH/src/github.com/HackerLoop/rotonde\r\ngodep restore\r\ngo build\r\n```\r\n\r\n`go build` will compile an executable called `rotonde` in the project\r\nfolder (`$GOPATH/src/HackerLoop/rotonde`).\r\n\r\nIf something goes wrong during compilation, please [open up an\r\nissue](https://github.com/HackerLoop/rotonde/issues) with your\r\nos/distribution infos and compilation output. \r\n\r\n## Running\r\n\r\n```bash\r\n./rotonde -port 4242\r\n```\r\n\r\n## JSON protocol\r\n\r\nIn most case, rotonde is used through its websocket (Rest interface is foreseen), by sending and receiving JSON objects.\r\nThere a five types of json objects, \"update\", \"req\", \"cmd\", \"sub\" or \"unsub\",\r\nwhich are detailed below.\r\n\r\nThese four json objects all share a common structure :\r\n\r\n```\r\n{\r\n  type: \"\", // \"update\", \"req\", \"cmd\", \"sub\" or \"unsub\"\r\n  payload: {\r\n    // mixed, based on type\r\n  }\r\n}\r\n```\r\n\r\n### Update\r\n\r\nThe \"update\" object encapsulate an update of a Object, which can be\r\nfound in two different contexts.\r\n\r\n- Received as a notification that a setting had been updated.\r\n- Sent to update a setting\r\n\r\nFor example, the attitude module (which is responsible for attitude estimation, which means \"what is the current angle of the drone\") will periodically send the quaternion representing the current angle of the drone through the AttitudeActual object.\r\n\r\nBut \"update\" objects can also be used to set setting values for the desired module, for example, if you send a [AttitudeSettings](https://raw.githubusercontent.com/TauLabs/TauLabs/next/shared/uavobjectdefinition/attitudesettings.xml) update object through websocket it will configure the PID algorithm that enables your drone to stay still in the air.\r\n\r\n```\r\n{\r\n  \"type\": \"update\",\r\n  \"payload\": {\r\n    // objectId and instanceId are both required\r\n    \"objectId\": 1234, // displayed on start of rotonde\r\n    \"instanceId\": 0, // see UAVTalk documentation for info\r\n    \"data\": {\r\n      // Object data, as described by the definitions\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Req\r\n\r\nSome Objects are sent periodically, like the AttitudeActual that is sent every 100 ms, but others have different update policies, for example, the AttitudeSettings object is sent when changed, which means if you want its value you can either wait for it to change (which should not occure in normal condition), or just request it by sending a \"req\" object into the pipe, the response will be received as a \"update\" object.\r\n\r\n```\r\n{\r\n  \"type\": \"req\",\r\n  \"payload\": {\r\n    \"objectId\": 1234, // displayed on start of rotonde, will be received from the def packet\r\n    \"instanceId\": 0, // see UAVTalk documentation for info\r\n  }\r\n}\r\n```\r\n\r\n### Sub / Unsub\r\n\r\nWhen you connect to rotonde nothing will be received except definitions, you have to subscribe to a given objectId in order to start receiving its updates.\r\n\r\n```\r\n{\r\n  \"type\": \"sub\",\r\n  \"payload\": {\r\n    \"objectId\": 1234 // displayed on start of rotonde, will be received from the def packet\r\n  }\r\n}\r\n```\r\n\r\nand you can unsubscribe from this objectId with:\r\n\r\n```\r\n{\r\n  \"type\": \"unsub\",\r\n  \"payload\": {\r\n    \"objectId\": 1234 // displayed on start of rotonde, will be received from the def packet\r\n  }\r\n}\r\n```\r\n\r\n### Def\r\n\r\nEach Object has a set of fields and meta datas, when a Object is available (like GPS), the module providing this feature sends its definition to rotonde which then dispatches a definition to the clients.\r\nGiven that a Object reflects an available feature of the drone, definitions give clients a clear overview of the available features.\r\nA client can send definitions to rotonde, exposing the feature that it provides.\r\n\r\nWhen you connect to rotonde, it will start be sending you all the currently available definitions, new definitions can still become available at any time.\r\n\r\n```\r\n{\r\n  \"type\": \"def\",\r\n  \"payload\": {\r\n    // meta datas from Object, at first will be tightly linked to definitions found in the xml files\r\n  }\r\n}\r\n```\r\n\r\n#Licence\r\n\r\n[Apache licence 2.0 ](https://github.com/HackerLoop/rotonde/blob/master/licence.md)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}